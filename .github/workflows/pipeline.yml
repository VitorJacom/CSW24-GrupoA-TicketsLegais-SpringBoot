name: CI/CD Pipeline - Build, Test, Dockerize, and Deploy Spring Boot API

on:
  push:
    branches:
      - pipeline/docker
  pull_request:
    branches:
      - pipeline/docker

jobs:
  terraform:
    name: Setup Infrastructure with Terraform
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Source Code
        uses: actions/checkout@v3

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0  # Especifique a versão do Terraform que você está utilizando

      - name: Terraform Init
        working-directory: ./.infra  # Diretório onde está seu código Terraform
        run: terraform init

      - name: Terraform Format Check
        working-directory: ./.infra
        run: terraform fmt -check

      - name: Terraform Validate
        working-directory: ./.infra
        run: terraform validate

      - name: Terraform Plan
        working-directory: ./.infra
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        working-directory: ./.infra
        run: terraform apply -auto-approve tfplan

      - name: Capture Terraform Outputs
        id: terraform_outputs
        working-directory: ./.infra
        run: |
          echo "Fetching Terraform outputs..."
          terraform_output=$(terraform output -json)
          echo "terraform_output=$terraform_output" >> $GITHUB_ENV

      - name: Set Terraform Outputs as Environment Variables
        run: |
          export LAMBDA_BUCKET_NAME=$(echo $terraform_output | jq -r '.lambda_bucket_name.value')
          export API_ID=$(echo $terraform_output | jq -r '.api_id.value')
          export PROXY_RESOURCE_ID=$(echo $terraform_output | jq -r '.proxy_resource_id.value')
          export ACCOUNT_ID=$(echo $terraform_output | jq -r '.account_id.value')
          export DB_ADDRESS=$(echo $terraform_output | jq -r '.my_db_address.value')
          export DB_NAME=$(echo $terraform_output | jq -r '.my_db_name.value')
          export DB_USERNAME=$(echo $terraform_output | jq -r '.my_db_username.value')
          export DB_PASSWORD=$(echo $terraform_output | jq -r '.my_db_password.value')
          export LAMBDA_ROLE_ARN=$(echo $terraform_output | jq -r '.lambda_role_arn.value')

          echo "LAMBDA_BUCKET_NAME=$LAMBDA_BUCKET_NAME" >> $GITHUB_ENV
          echo "API_ID=$API_ID" >> $GITHUB_ENV
          echo "PROXY_RESOURCE_ID=$PROXY_RESOURCE_ID" >> $GITHUB_ENV
          echo "ACCOUNT_ID=$ACCOUNT_ID" >> $GITHUB_ENV
          echo "DB_ADDRESS=$DB_ADDRESS" >> $GITHUB_ENV
          echo "DB_NAME=$DB_NAME" >> $GITHUB_ENV
          echo "DB_USERNAME=$DB_USERNAME" >> $GITHUB_ENV
          echo "DB_PASSWORD=$DB_PASSWORD" >> $GITHUB_ENV
          echo "LAMBDA_ROLE_ARN=$LAMBDA_ROLE_ARN" >> $GITHUB_ENV

    outputs:
      lambda_bucket_name: ${{ env.LAMBDA_BUCKET_NAME }}
      api_id: ${{ env.API_ID }}
      proxy_resource_id: ${{ env.PROXY_RESOURCE_ID }}
      account_id: ${{ env.ACCOUNT_ID }}
      db_address: ${{ env.DB_ADDRESS }}
      db_name: ${{ env.DB_NAME }}
      db_username: ${{ env.DB_USERNAME }}
      db_password: ${{ env.DB_PASSWORD }}
      lambda_role_arn: ${{ env.LAMBDA_ROLE_ARN }}

  build:
    name: Build and Test Spring Boot Application
    runs-on: ubuntu-latest
    needs: terraform  # Depende do job de Terraform

    steps:
      - name: Checkout Source Code
        uses: actions/checkout@v3

      - name: Cache Maven Packages
        uses: actions/cache@v3
        with:
          path: ~/.m2
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Wait for MySQL to be ready
        run: |
          echo "Waiting for MySQL to start..."
          for i in {1..20}; do
            if mysqladmin ping -h 127.0.0.1 -u root --password=root_password; then
              echo "MySQL is up and running"
              break
            fi
            echo "MySQL is unavailable - sleeping"
            sleep 10
          done

      - name: Build Docker Image
        run: docker build -t spring-boot-api-test .

      - name: Build and Test Application
        working-directory: ./ingressoLegais
        env:
          SPRING_DATASOURCE_URL: jdbc:mysql://localhost:3306/ingresso_legais?createDatabaseIfNotExist=true
          SPRING_DATASOURCE_USERNAME: root
          SPRING_DATASOURCE_PASSWORD: root_password
        run: ./mvnw clean verify -X

      - name: Upload JAR as Artifact
        uses: actions/upload-artifact@v3
        with:
          name: ingress-back-jar
          path: ./ingressoLegais/target/ingresso_back-1.0.0.jar

  deploy:
    name: Deploy to AWS Lambda and API Gateway
    runs-on: ubuntu-latest
    needs: [terraform, build]  # Depende dos jobs de Terraform e Build

    steps:
      - name: Checkout Source Code
        uses: actions/checkout@v3

      - name: Download JAR Artifact
        uses: actions/download-artifact@v3
        with:
          name: ingress-back-jar
          path: ./ingressoLegais/target/

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1  # Altere para sua região

      - name: Upload JAR to S3
        run: |
          aws s3 cp ingressoLegais/target/ingresso_back-1.0.0.jar s3://$LAMBDA_BUCKET_NAME/ingresso_back-1.0.0.jar

      - name: Create or Update Lambda Function
        run: |
          FUNCTION_NAME="tickets-legais-lambda"
          S3_BUCKET=$LAMBDA_BUCKET_NAME
          S3_KEY="ingresso_back-1.0.0.jar"
          ROLE_ARN=$LAMBDA_ROLE_ARN
          HANDLER="construcao_software.ingresso_back.adapter.handler.LambdaHandler"
          RUNTIME="java11"
          MEMORY_SIZE=1024
          TIMEOUT=30
          ENV_VARS="{\"SPRING_DATASOURCE_URL\":\"jdbc:mysql://$DB_ADDRESS:3306/$DB_NAME\",\"SPRING_DATASOURCE_USERNAME\":\"$DB_USERNAME\",\"SPRING_DATASOURCE_PASSWORD\":\"$DB_PASSWORD\"}"

          if aws lambda get-function --function-name $FUNCTION_NAME > /dev/null 2>&1; then
            echo "Updating existing Lambda function..."
            aws lambda update-function-code \
              --function-name $FUNCTION_NAME \
              --s3-bucket $S3_BUCKET \
              --s3-key $S3_KEY
          else
            echo "Creating new Lambda function..."
            aws lambda create-function \
              --function-name $FUNCTION_NAME \
              --runtime $RUNTIME \
              --role $ROLE_ARN \
              --handler $HANDLER \
              --code S3Bucket=$S3_BUCKET,S3Key=$S3_KEY \
              --memory-size $MEMORY_SIZE \
              --timeout $TIMEOUT \
              --environment Variables=$ENV_VARS
          fi

      - name: Grant API Gateway Permission to Invoke Lambda
        run: |
          FUNCTION_NAME="tickets-legais-lambda"
          SOURCE_ARN="arn:aws:apigateway:us-east-1::/restapis/$API_ID/stages/prod/*/*"

          aws lambda add-permission \
            --function-name $FUNCTION_NAME \
            --statement-id AllowAPIGatewayInvoke \
            --action lambda:InvokeFunction \
            --principal apigateway.amazonaws.com \
            --source-arn $SOURCE_ARN || echo "Permission already exists"

      - name: Update API Gateway Integration
        run: |
          FUNCTION_NAME="tickets-legais-lambda"
          URI="arn:aws:apigateway:us-east-1:lambda:path/2015-03-31/functions/arn:aws:lambda:us-east-1:$ACCOUNT_ID:function:$FUNCTION_NAME/invocations"

          aws api gateway put-integration \
            --rest-api-id $API_ID \
            --resource-id $PROXY_RESOURCE_ID \
            --http-method ANY \
            --type AWS_PROXY \
            --integration-http-method POST \
            --uri "$URI"

      - name: Deploy API Gateway
        run: |
          aws api gateway create-deployment \
            --rest-api-id $API_ID \
            --stage-name prod

      - name: Notify Deployment Success (Optional)
        if: success()
        uses: slackapi/slack-github-action@v1.23.0
        with:
          payload: |
            {
              "text": "Deploy da Lambda concluído com sucesso! Endpoint: https://$API_ID.execute-api.us-east-1.amazonaws.com/prod"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
